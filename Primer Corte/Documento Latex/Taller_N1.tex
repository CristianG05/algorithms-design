\documentclass{article} %%% use \documentstyle for old LaTeX compilers

\usepackage[english]{babel} %%% 'french', 'german', 'spanish', 'danish', etc.
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{txfonts}
\usepackage{mathdots}
\usepackage[classicReIm]{kpfonts}
\usepackage[dvips]{graphicx} %%% use 'pdftex' instead of 'dvips' for PDF output

% You can include more LaTeX packages here 


\begin{document}

%\selectlanguage{english} %%% remove comment delimiter ('%') and select language if required


\noindent 

\noindent 

\noindent 

\noindent 

\noindent 

\noindent Dise\~{n}o De Software - M\'{e}todos De Ordenamiento

\noindent Michael Daniel Murillo L\'{o}pez

\noindent Ingenier\'{i}a De Sistemas

\noindent Corporaci\'{o}n Universitaria Minuto De Dios

\noindent 

\noindent Como parte de un ejercicio t\'{i}pico de Desarrollo de algoritmos de software, hice un peque\~{n}o an\'{a}lisis comparativo de los algoritmos de ordenamiento m\'{a}s populares, buscando estudiar la complejidad de cada uno de estos y como las diferentes formas de resolver un mismo problema pueden afectar los tiempos de ejecuci\'{o}n. Quiero aclarar que este es solo un an\'{a}lisis acad\'{e}mico muy simple que quiero documentar, el cual tal vez sirva a futuro para otros estudiantes de ciencias de la computaci\'{o}n.

\noindent El usuario debe poder ingresar una serie de n\'{u}meros separados por comas, y estos se entender\'{a}n como el conjunto de n\'{u}meros del arreglo, y usando un men\'{u} en la consola debe poder seleccionar algoritmo utilizar.

\begin{enumerate}
\item  \textbf{Bubble Sort:}
\end{enumerate}

\noindent Este es uno de los algoritmos m\'{a}s simples de ordenamiento. Este algoritmo se basa en la comparaci\'{o}n de elementos, particularmente entre parejas adyacentes, y si la pareja a comparar no est\'{a} ordenada, simplemente se intercambian; el algoritmo concluye cuando al hacer todo el recorrido, y hacer todas las comparaciones entre vecinos adyacentes, no se requieren realizar m\'{a}s intercambios.  Este algoritmo no es recomendable para arreglos con gran cantidad de datos, ya que tanto su caso promedio como su peor caso tienen un orden de crecimiento de $\Theta$(n2).

\noindent 

\noindent Data: A: Unsorted array of numbers Result: A*: Sorted array of numbers for i $\mathrm{\leftarrow}$ 0 to length(A) $\mathrm{-}$ 1 do

\noindent swapped $\mathrm{\leftarrow}$ false

\noindent for j $\mathrm{\leftarrow}$ 0 to length(A) $\mathrm{-}$ 1 do

\noindent /* compare to adjacent elements */

\noindent if array[j] $\mathrm{>}$ array [j + 1] then

\noindent /* swap them */

\noindent auxSwap $\mathrm{\leftarrow}$ array[j] array[j] $\mathrm{\leftarrow}$ array [j + 1] array [j + 1] $\mathrm{\leftarrow}$ swap swapped $\mathrm{\leftarrow}$ true

\noindent end

\noindent end

\noindent /* if no number was swapped, the array is sorted now */

\noindent if not swapped then

\noindent break

\noindent end

\noindent end

\noindent Algoritmo 1: Bubble Sort

\noindent 

\begin{enumerate}
\item  \textbf{Merge Sort:}
\end{enumerate}

Este es un algoritmo de ordenamiento que est\'{a} basado en el paradigma de divide y vencer\'{a}s. Este es considerado uno de los mejores algoritmos para ordenar elementos de un arreglo, puesto que en el peor de los casos el orden de crecimiento que tiene es de $\Theta$(nlogn). La estrategia que maneja Merge Sort es simple:  el arreglo se divide en dos partes por la mitad, y este proceso se repite hasta que se llegue a arreglos de tama\~{n}o

\noindent 1: luego, cada una de las soluciones se combina de manera ordenada, obteniendo de manera emergente al final el arreglo total completamente ordenado.

\noindent Data: A: Unsorted array of numbers Result:  A*: Sorted array of numbers if lenght(A) == 1 then

\noindent /* array is already sorted */

\noindent return A

\noindent else

\noindent /* split in two parts */

\noindent left sub-array $\mathrm{\leftarrow}$ A [0] . . . A [n / 2]

\noindent right sub-array $\mathrm{\leftarrow}$ A [(n / 2) + 1] . . . A[n]

\noindent /* sort each one of the parts */ sortedL $\mathrm{\leftarrow}$ MergeSort (left sub-array) sortedR $\mathrm{\leftarrow}$ MergeSort (right sub-array)

\noindent /* follow the stratefy divide and conquer */

\noindent return Merge (sortedL, sortedR)

\noindent end

\noindent Algoritmo 3: Merge Sort

\noindent 

\noindent Data:  A: Sorted array of numbers, B: Sorted array of numbers

\noindent Result:  C: Sorted array of numbers that contains all elements of both A and B

\noindent l $\mathrm{\leftarrow}$ length(A) + length(B)

\noindent /* create C array */

\noindent C $\mathrm{\to}$ Array of length l

\noindent indexA $\mathrm{\leftarrow}$ 0, indexB $\mathrm{\leftarrow}$ 0, indexC $\mathrm{\leftarrow}$ 0

\noindent while A and B have elements do

\noindent if A[indexA] $\mathrm{<}$ B[indexB] then

\noindent /* add element from A array */

\noindent C[indexC] $\mathrm{\leftarrow}$ A[indexA] indexA $\mathrm{\leftarrow}$ indexA + 1 indexC $\mathrm{\leftarrow}$ indexC + 1

\noindent else

\noindent /* add element from B array */

\noindent C[indexC] $\mathrm{\leftarrow}$ B[indexB] indexB $\mathrm{\leftarrow}$ indexB + 1 indexC $\mathrm{\leftarrow}$ indexC + 1

\noindent end

\noindent end

\noindent /* one of A or B has still some elements */

\noindent while A has elements do C[indexC] $\mathrm{\leftarrow}$ A[indexA] indexA $\mathrm{\leftarrow}$ indexA + 1 indexC $\mathrm{\leftarrow}$ indexC + 1

\noindent end

\noindent while B has elements do C[indexC] $\mathrm{\leftarrow}$ B[indexB] indexB $\mathrm{\leftarrow}$ indexB + 1 indexC $\mathrm{\leftarrow}$ indexC + 1

\noindent end

\noindent return C

\noindent Algoritmo 4: Merge

\noindent 

\noindent \textbf{}

\begin{enumerate}
\item \textbf{ Quick Sort:}
\end{enumerate}

\noindent \textbf{}

\noindent Este es uno de los algoritmos de ordenamiento m\'{a}s eficientes que existe (suele utilizarse con grandes conjuntos de datos, y su eficiencia tanto en casos promedio como en el peor caso es de $\Theta$(nlogn)), el cual consiste en una estrategia de divide y vencer\'{a}s debido a que siempre parte el arreglo en peque\~{n}os sub-arreglos, y este proceso se repite de manera recursiva.   Particularmente, en este algoritmo se usa la noci\'{o}n de pivote para definir la construcci\'{o}n de los sub-arreglos, en donde los valores m\'{a}s peque\~{n}os que el pivote van al primer sub-arreglo, y los mayores van al segundo sub-arreglo.   Tradicionalmente, se selecciona el primer elemento del arreglo como el pivote, y de igual manera se selecciona en los sub-arreglos mientras se est\'{a} haciendo la recursividad; valga aclarar que el pivote, luego de hacer el proceso de partici\'{o}n ya se encuentra en el lugar que tendr\'{a} finalmente en el conjunto ordenado.

\noindent \textbf{}

\noindent Data: A: Unsorted array of numbers Result:  A*: Sorted array of numbers if length(A) == 1 then

\noindent /* array A is already sorted */

\noindent return A

\noindent else

\noindent /* take first set element as a pivot */

\noindent pivot $\mathrm{\leftarrow}$ A [0]

\noindent for i $\mathrm{\leftarrow}$ 1 to length(A) do

\noindent /* build both less and greater than pivot subarrays */

\noindent if A[i] $\mathrm{<}$ pivot then

\noindent less subarray.add $\mathrm{\leftarrow}$ A[i]

\noindent else

\noindent greater subarray.add $\mathrm{\leftarrow}$ A[i]

\noindent end

\noindent /* call recursion for each one of the subarrays, and concatenate the results */

\noindent return QuickSort (less subarray) + pivot + QuickSort (greater subarray)

\noindent end

\noindent end

\noindent Algoritmo 5: Quick Sort

\noindent 

\begin{enumerate}
\item  \textbf{Conclusiones}
\end{enumerate}

\noindent \textbf{}

\noindent Los algoritmos de ordenaci\'{o}n r\'{a}pida y fusi\'{o}n se basan en el algoritmo de divisi\'{o}n y conquista que funciona de manera bastante similar. La diferencia previa entre la ordenaci\'{o}n r\'{a}pida y la fusi\'{o}n es que en la ordenaci\'{o}n r\'{a}pida el elemento pivote se usa para la ordenaci\'{o}n. Por otro lado, la ordenaci\'{o}n por fusi\'{o}n no utiliza el elemento pivote para realizar la ordenaci\'{o}n. La ordenaci\'{o}n r\'{a}pida es casos m\'{a}s r\'{a}pidos, pero es ineficiente en algunas situaciones y tambi\'{e}n realiza muchas comparaciones en comparaci\'{o}n con la ordenaci\'{o}n por fusi\'{o}n. Aunque la ordenaci\'{o}n por fusi\'{o}n requiere menos comparaci\'{o}n, necesita un espacio de memoria adicional de 0 (n) para almacenar la matriz adicional, mientras que la ordenaci\'{o}n r\'{a}pida necesita espacio de O (log n).

\noindent \textbf{}

\begin{tabular}{|p{0.8in}|p{0.6in}|p{0.6in}|p{0.6in}|} \hline 
~ & Bubble Sort & Merge Sort & Quick Sort \\ \hline 
1000 & 0,55 & 0,388 & 0,501 \\ \hline 
5000 & 0,143 & 1,827 & 4,71 \\ \hline 
50000 & 9,558 & 18,494 & 498,768 \\ \hline 
100000 & 34,606 & 34,368 & 5035,547 \\ \hline 
500000 & 771,864 & 191,841 & 0,001 \\ \hline 
1000000 & 3171,462 & 520,621 & 0,001 \\ \hline 
\end{tabular}



\noindent 

\noindent \includegraphics*[width=6.13in, height=3.65in, keepaspectratio=false]{image2}

\noindent 

\noindent (Bubble  Sort):  O(nˆ 2)

\noindent (Merge Sort):  O(n log n)

\noindent (Quick sort): O(n log n)


\end{document}

